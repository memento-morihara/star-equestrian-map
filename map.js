import {
    food,
    collectibles,
    resources,
    chests,
    other
} from './markers.js';

// import { records, addMarker, deleteMarker } from './dev/pocketbase.js';
import locations from './locations.js';

const options = [
    "<optgroup label='Food'>" + food.map(f => `<option value="${f.name}">${f.name}</option>`) + "</optgroup>",
    "<optgroup label='Resources'>" + resources.map(r => `<option value="${r.name}">${r.name}</option>`) + "</optgroup>",
    "<optgroup label='Chests'>" + chests.map(h => `<option value="${h.name}">${h.name}</option>`) + "</optgroup>",
    "<optgroup label='Collectibles'>" + collectibles.map(c => `<option value="${c.name}">${c.name}</option>`) + "</optgroup>",
    "<optgroup label='Other'>" + other.map(o => `<option value="${o.name}">${o.name}</option>`) + "</optgroup>",
]

let locPopup;

let markerEditMenu = (loc, values) => `<select id="name" class="form-select form-select-sm" value="${values?.name}">${options}</select><textarea id="description" class="form-control" rows="2" value="${values?.description}"></textarea><button id="addButton" class="btn btn-primary btn-sm">Add marker</button><small>[${loc.latlng.lat}, ${loc.latlng.lng}]</small>`

const onCtxMenuClick = (e) => {
    createTempMarker(e.latlng);
    locPopup = L.popup({
        offset: [ 0, -7 ],
        minWidth: 178,
        maxWidth: 250
    }).setLatLng(e.latlng).setContent(markerEditMenu(e)).openOn(map);

    const name = document.querySelector("#name")
    const description = document.querySelector("textarea");
    document.querySelector("#addButton").addEventListener("click", function () {
        addMarker(e.latlng.lat, e.latlng.lng, name.value, description.value)
        locPopup.remove();
        newMarker(e.latlng, name.value, description.value)
    })
}

const genericMarker = L.icon({
    iconUrl: "./se-marker.svg",
    iconSize: [ 28, 28 ],
    iconAnchor: [ 14, 28 ],
    popupAnchor: [ 0, -14 ]
})

let tempMarker = L.marker([ 0, 0 ], {
    icon: genericMarker,
})

function createTempMarker(loc) {
    tempMarker.setLatLng(loc).addTo(map);
}


// // Autogenerated code from MapTiler
const mapExtent = [ 0.00000000, -4242.00000000, 11061.00000000, 0.00000000 ];
const mapMinZoom = 0;
const mapMaxZoom = 5;
const mapMaxResolution = 1.00000000;
const mapMinResolution = Math.pow(2, mapMaxZoom) * mapMaxResolution;
const tileExtent = [ 0.00000000, -4242.00000000, 11061.00000000, 0.00000000 ];
const crs = L.CRS.Simple;
crs.transformation = new L.Transformation(1, -tileExtent[ 0 ], -1, tileExtent[ 3 ]);
crs.scale = function (zoom) {
    return Math.pow(2, zoom) / mapMinResolution;
};
crs.zoom = function (scale) {
    return Math.log(scale * mapMinResolution) / Math.LN2;
}

export let map = L.map('map', {
    maxZoom: mapMaxZoom,
    minZoom: mapMinZoom,
    crs: crs,
    condensedAttributionControl: false, // Attribution is added back in later, don't worry!
    // For development
    contextmenu: true,
    contextmenuItems: [
        {
            'text': 'Add Marker',
            'index': 0,
            'callback': onCtxMenuClick
        },
    ],
});

L.tileLayer('./tiles/{z}/{x}/{y}.webp', {
    minZoom: mapMinZoom,
    maxZoom: mapMaxZoom,
    tileSize: L.point(512, 512),
    attribution: '<a href="https://www.maptiler.com/engine/">Rendered with MapTiler Engine</a>, non-commercial use only',
    noWrap: true,
    tms: false
}).addTo(map);
map.fitBounds([
    crs.unproject(L.point(mapExtent[ 2 ], mapExtent[ 3 ])),
    crs.unproject(L.point(mapExtent[ 0 ], mapExtent[ 1 ]))
]);

// L.control.mousePosition().addTo(map)

const oms = new OverlappingMarkerSpiderfier(map, {
    keepSpiderfied: true,
    legColors: {
        usual: "white",
        highlighted: "red"
    }
});

L.control.sidepanel('menu', {
    hasTabs: true,
}).addTo(map);

let selectedMarker;

let foodFeatureGroup = L.featureGroup().addTo(map);
let resourcesFeatureGroup = L.featureGroup().addTo(map);
let chestsFeatureGroup = L.featureGroup().addTo(map);
let collectiblesFeatureGroup = L.featureGroup().addTo(map);
let otherFeatureGroup = L.featureGroup().addTo(map);

function toggleEditable(marker) {
    marker && (marker.dragging.enabled ? marker.dragging.disable() : marker.dragging.enable());
}


export function newMarker(loc, name, description, id) {
    const obj = [ food, resources, chests, collectibles, other ].flat().find(x => x.name === name);
    const marker = L.marker(loc, {
        name: name,
        description: description,
        id: id,
        riseOnHover: true,
        icon: (obj && obj.icon) || L.icon({
            iconUrl: './se-marker.svg',
        }),
        contextmenu: true,
        contextmenuInheritItems: false,
        contextmenuItems: [
            {
                'text': 'Reposition',
                'index': 0,
                'callback': (e) => toggleEditable(e.target)
            },
            {
                'text': 'Delete',
                'index': 1,
                'callback': () => {
                    deleteMarker(selectedMarker.options.id);
                    selectedMarker.remove();
                }
            }
        ]
    }).addTo(map);
    marker.bindPopup(`<h2 class="marker-title">${name}</h2><p>${description ?? ""}`);
    oms.addMarker(marker);
    // addFeatures(marker);
    marker.on('contextmenu click', () => {
        selectedMarker = marker;
        console.log(selectedMarker)
    });

    return marker;
}

// Removes the temporary marker if you click away from it
map.on('popupclose contextmenu.hide', function (e) {
    tempMarker && tempMarker.remove();
})

// Prevent marker popup when clicking on a group of markers
oms.addListener('spiderfy', function () {
    map.closePopup();
});

let markers = [];

async function getMarkers() {
    let list = locations;
    for (let location of list) {
        let marker = newMarker([ location.lat, location.lng ], location.name, location.description, location.id);
        markers.push(marker);
    }
}

//Get the name of the objects in the arrays to compare against the marker's name
let groups = [ food, resources, chests, collectibles, other ].map(x => x.map(y => y.name));

function divideIntoGroups(marker) {
    // Find the index of the group in the groups array that contains the marker's name
    switch (groups.indexOf(groups.find(g => g.includes(marker.options.name)))) {
        case 0:
            return foodFeatureGroup;
        case 1:
            return resourcesFeatureGroup;
        case 2:
            return chestsFeatureGroup;
        case 3:
            return collectiblesFeatureGroup;
        case 4:
            return otherFeatureGroup;
    }
};


function addFeatures(marker) {
    divideIntoGroups(marker).addLayer(marker);
}


map.whenReady(getMarkers)

function toggleMarkerGroup(markerGroup) {
    map.hasLayer(markerGroup) ? markerGroup.remove() : markerGroup.addTo(map);
}

function toggleMarker(marker) {
    map.hasLayer(marker) ? marker.remove() : marker.addTo(map);
}

let visibleFeatures = []

let checkboxes = document.querySelectorAll("input[type=checkbox]")
checkboxes.forEach(c => {
    c.checked && visibleFeatures.push({
        name: c.value,
        group: c.getAttribute("data-feature-group")
    });
    c.addEventListener("change", function () {
        // TODO: refactor to use FeatureGroups for each type of item
        markers.filter(m => m.options.name.toLowerCase().split(" ").join("-") === c.value.toLowerCase()).forEach(m => {
            toggleMarker(m)
        })
    })
})

L.control.condensedAttribution({
    prefix: `Images &copy; <a href="https://www.foxieventures.com">Foxie Ventures</a>`
}).addTo(map)


// Also for development
map.on('contextmenu', function (e) {
    createTempMarker(e.latlng);
});

