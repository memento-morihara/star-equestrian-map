import {
	food,
	collectibles,
	resources,
	chests,
	other
} from './markers.js';

import locations from './locations.js'

// For development
// import {
// 	createTempMarker,
// 	onCtxMenuClick,
// 	tempMarker
// } from './dev/dev-markers.js'

// Autogenerated code from MapTiler
var mapExtent = [ 0.00000000, -4242.00000000, 11061.00000000, 0.00000000 ];
var mapMinZoom = 0;
var mapMaxZoom = 5;
var mapMaxResolution = 1.00000000;
var mapMinResolution = Math.pow(2, mapMaxZoom) * mapMaxResolution;
var tileExtent = [ 0.00000000, -4242.00000000, 11061.00000000, 0.00000000 ];
var crs = L.CRS.Simple;
crs.transformation = new L.Transformation(1, -tileExtent[ 0 ], -1, tileExtent[ 3 ]);
crs.scale = function (zoom) {
	return Math.pow(2, zoom) / mapMinResolution;
};
crs.zoom = function (scale) {
	return Math.log(scale * mapMinResolution) / Math.LN2;
}

export let map = new L.Map('map', {
	maxZoom: mapMaxZoom,
	minZoom: mapMinZoom,
	crs: crs,
	condensedAttributionControl: false, // Attribution is added back in later, don't worry!

	// For development
	// contextmenu: true,
	// contextmenuItems: [
	// 	{
	// 		'text': 'Add Marker',
	// 		'index': 0,
	// 		'callback': onCtxMenuClick
	// 	},
	// ],
});

// Also for development
// map.on('contextmenu', function (e) {
// 	createTempMarker(e.latlng);
// });

// Removes the temporary marker if you click away from it
// map.on('popupclose contextmenu.hide', function (e) {
// 	tempMarker && tempMarker.remove();
// })

L.tileLayer('./tiles/{z}/{x}/{y}.webp', {
	minZoom: mapMinZoom,
	maxZoom: mapMaxZoom,
	tileSize: L.point(512, 512),
	attribution: '<a href="https://www.maptiler.com/engine/">Rendered with MapTiler Engine</a>, non-commercial use only',
	noWrap: true,
	tms: false
}).addTo(map);
map.fitBounds([
	crs.unproject(L.point(mapExtent[ 2 ], mapExtent[ 3 ])),
	crs.unproject(L.point(mapExtent[ 0 ], mapExtent[ 1 ]))
]);

function addToFeatureGroup(featureGroup, feature) {
	featureGroup.addLayer(feature);
}

var oms = new OverlappingMarkerSpiderfier(map, {
	keepSpiderfied: true,
	legColors: {
		usual: "white",
		highlighted: "red"
	}
});

let selectedMarker;

let foodFeatureGroup = L.featureGroup().addTo(map);
let resourcesFeatureGroup = L.featureGroup().addTo(map);
let chestsFeatureGroup = L.featureGroup().addTo(map);
let collectiblesFeatureGroup = L.featureGroup().addTo(map)
let otherFeatureGroup = L.featureGroup().addTo(map)

export function newMarker(loc, name, description) {
	const obj = [ food, resources, chests, collectibles, other ].flat().find(x => x.name === name);
	const marker = L.marker(loc, {
		name: name,
		description: description,
		icon: obj.icon,
		riseOnHover: true,
	}).addTo(map);
	marker.bindPopup(`<h2 class="marker-title">${name}</h2><p>${description ?? ""}</p>`);
	oms.addMarker(marker)
	addFeatures(marker)

	marker.addEventListener("click", () => selectedMarker = marker);
	return marker;
}


let markers = [];

async function getMarkers() {
	for (let location of locations) {
		let marker = newMarker([ location.lat, location.long ], location.name, location.description);
		markers.push(marker);
	}
}

L.control.sidepanel('menu', {
	hasTabs: true,
}).addTo(map);


function divideIntoGroups(marker) {
	//Get the name of the objects in the arrays to compare against the marker's name
	let groups = [ food, resources, chests, collectibles, other ].map(x => x.map(y => y.name));

	// Find the index of the group in the groups array that contains the marker's name
	switch (groups.indexOf(groups.find(g => g.includes(marker.options.name)))) {
		case 0:
			return foodFeatureGroup;
		case 1:
			return resourcesFeatureGroup;
		case 2:
			return chestsFeatureGroup;
		case 3:
			return collectiblesFeatureGroup;
		case 4:
			return otherFeatureGroup;
	}
}


function addFeatures(marker) {
	divideIntoGroups(marker).addLayer(marker)
}


// Prevent marker popup when clicking on a group of markers
oms.addListener('spiderfy', function () {
	map.closePopup();
});

map.whenReady(getMarkers)
markers.map(m => divideIntoGroups(m))

function toggleMarkerGroup(markerGroup) {
	map.hasLayer(markerGroup) ? markerGroup.remove() : markerGroup.addTo(map);
}

function toggleMarker(marker) {
	map.hasLayer(marker) ? marker.remove() : marker.addTo(map);
}

let visibleFeatures = []

let checkboxes = document.querySelectorAll("input[type=checkbox]")
checkboxes.forEach(c => {
	c.checked && visibleFeatures.push({
		name: c.value,
		group: c.getAttribute("data-feature-group")
	});
	c.addEventListener("change", function () {
		// TODO: refactor to use FeatureGroups for each type of item
		markers.filter(m => m.options.name.toLowerCase().split(" ").join("-") === c.value.toLowerCase()).forEach(m => {
			toggleMarker(m)
		})
	})
})

L.control.condensedAttribution({
	prefix: `Images &copy; <a href="https://www.foxieventures.com">Foxie Ventures</a>`
}).addTo(map)
