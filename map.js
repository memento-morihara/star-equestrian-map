import {
	food,
	collectibles,
	resources,
	chests,
	other
} from './markers.js';
import {locations, counts} from './locations.js';
import { shownItems, addItem, removeItem, items } from './data.js';
import {Marker} from './marker.js';
import {atom} from "nanostores";

// // Autogenerated code from MapTiler
const mapExtent = [ 0.00000000, -16384.00000000, 16384.00000000, 0.00000000 ];
const mapMinZoom = 0;
const mapMaxZoom = 4;
const mapMaxResolution = 2.00000000;
const mapMinResolution = Math.pow(2, mapMaxZoom) * mapMaxResolution;
const tileExtent = [ 0.00000000, -16384.00000000, 16384.00000000, 0.00000000 ];
const crs = L.CRS.Simple;
crs.transformation = new L.Transformation(1, -tileExtent[ 0 ], -1, tileExtent[ 3 ]);
crs.scale = function (zoom) {
	return Math.pow(2, zoom) / mapMinResolution;
};
crs.zoom = function (scale) {
	return Math.log(scale * mapMinResolution) / Math.LN2;
};
export let map = new L.Map('map', {
	maxZoom: mapMaxZoom,
	minZoom: mapMinZoom,
	crs: crs,
	condensedAttributionControl: false,
});

L.tileLayer('./tiles/{z}/{x}/{y}.webp', {
	minZoom: mapMinZoom, maxZoom: mapMaxZoom,
	tileSize: L.point(512, 512),
	attribution: '<a href="https://www.maptiler.com/engine/">Rendered with MapTiler Engine</a>, non-commercial use only',
	noWrap: true,
	tms: false
}).addTo(map);
map.fitBounds([
	crs.unproject(L.point(mapExtent[ 2 ], mapExtent[ 3 ])),
	crs.unproject(L.point(mapExtent[ 0 ], mapExtent[ 1 ]))
]);

const oms = new OverlappingMarkerSpiderfier(map, {
	keepSpiderfied: true,
	legColors: {
		usual: "white",
		highlighted: "red"
	}
});

function getCount(itemName) {
  const item = counts.find(i => itemName.includes(i.name.toLowerCase().split(" ").join("-")));
  return item && item.count
}

const itemLabels = document.querySelectorAll(' sl-tree-item > sl-tree-item');
itemLabels.forEach(i => i.innerText += ` (${getCount(i.getAttribute("data-value"))})`);

let selectedMarker;

let foodFeatureGroup = L.featureGroup().addTo(map);
let resourcesFeatureGroup = L.featureGroup().addTo(map);
let chestsFeatureGroup = L.featureGroup().addTo(map);
let collectiblesFeatureGroup = L.featureGroup().addTo(map);
let otherFeatureGroup = L.featureGroup().addTo(map);


export function newMarker(id, name, lat, lng, description) {
	const obj = new Marker(id, name, lat, lng, description);
	const marker = obj.mapMarker;
	if (obj.lastCollectedDate) {
		marker.setOpacity(0.5)
	}
	oms.addMarker(marker);
	// addFeatures(marker);
	marker.on('contextmenu click', () => {
		selectedMarker = marker;
		document.querySelector("#collect")?.addEventListener("click", () => obj.collect())
		document.querySelector("#no-respawn")?.addEventListener("click", () => obj.noSpawn())
	});

	return marker;
}

// Prevent marker popup when clicking on a group of markers
oms.addListener('spiderfy', function () {
	map.closePopup();
});

let markers = [];

async function getMarkers() {
	for (let location of locations) {
		let marker = newMarker(location.id, location.name, location.lat, location.lng, location.description);
		markers.push(marker);
	}
}

//Get the name of the objects in the arrays to compare against the marker's name
let groups = [ food, resources, chests, collectibles, other ].map(x => x.map(y => y.name));

function divideIntoGroups(marker) {
	// Find the index of the group in the groups array that contains the marker's name
	switch (groups.indexOf(groups.find(g => g.includes(marker.options.name)))) {
		case 0:
			return foodFeatureGroup;
		case 1:
			return resourcesFeatureGroup;
		case 2:
			return chestsFeatureGroup;
		case 3:
			return collectiblesFeatureGroup;
		case 4:
			return otherFeatureGroup;
	}
}


function addFeatures(marker) {
	divideIntoGroups(marker).addLayer(marker);
}
let visibleFeatures = []
// let checkboxes = document.querySelectorAll("sl-checkbox");
let parentCheckboxes = document.querySelectorAll("sl-checkbox[data-feature-parent]");
let childCheckboxes = document.querySelectorAll("sl-checkbox[data-feature-group]")

const checkboxes = document.querySelectorAll("sl-tree-item");
const tree = document.querySelector("sl-tree");

map.whenReady(getMarkers)
initMarkers();
initSlCheckboxes();

function initMarkers() {
	let initialMarkers = shownItems.get();

	initialMarkers.forEach(item => {
		valueToMarker(item).forEach(x => toggleMarker(x));
		checkboxes.forEach(c => {
			if (c.getAttribute("data-value").includes(item)) {
				c.setAttribute("selected", "true");
			}
		})
	});
}


function toggleMarkerGroup(markerGroup) {
	map.hasLayer(markerGroup) ? markerGroup.remove() : markerGroup.addTo(map);
}

function toggleMarker(marker) {
	if (map.hasLayer(marker)) { marker.remove(); removeItem(marker.options.name.toLowerCase().split(" ").join("-")); } else { marker.addTo(map); if (!shownItems.get().includes(marker.options.name.toLowerCase().split(" ").join("-"))) { addItem(marker.options.name.toLowerCase().split(" ").join("-")); } }
}


function valueToMarker(name) {
	return markers.filter(marker => marker.options.name.toLowerCase().split(" ").join("-") === name.toLowerCase());
}



function slTreeValues(array) {
	let result = [];
	 array.forEach(item => result.push(item.getAttribute("data-value")));
	 return result;
}

function initSlCheckboxes() {
	const selectedItems = atom(Array.from(document.querySelectorAll("sl-tree-item[selected]")));
	parentCheckboxes.forEach(item => isIndeterminate(item))
	slTreeValues(selectedItems.get()).forEach(v => valueToMarker(v).forEach(m => toggleMarker(m)));
	const mutationObserver = document.querySelector('sl-mutation-observer');

	// The mutationObserver returns an array of tree items that have been (un)selected
	// Get this array and for each value, find the associated markers and toggle them
	mutationObserver.addEventListener("sl-mutation", e => {
		const values = [];
		e.detail.mutationList.forEach(v => values.push(v.target.getAttribute("data-value")));
		values.forEach(value => valueToMarker(value).forEach(marker => toggleMarker(marker)))
	})
}

function isIndeterminate(parent) {
	let siblings = [];
	let children = parent.getChildrenItems();
	// If all children are checked, parent becomes checked
	// If at least one child but not all is checked, parent becomes indeterminate
	for (const child of children) {
		if (child.selected) {
			siblings.push(child);
		}
	}

	if (children.length === siblings.length) {
		parent.selected = true;
		parent.indeterminate = false;
	} else
		if (siblings.length > 0) {
			parent.selected = false; // For Shoelace, indeterminate doesn't override checked
			parent.indeterminate = true;
		} else if (siblings.length === 0) {
			parent.selected = false;
			parent.indeterminate = false;
		}
}


L.control.condensedAttribution({
	prefix: `Images &copy; <a href="https://www.foxieventures.com">Foxie Ventures</a>`
}).addTo(map)

L.control.sidepanel('menu', {
	hasTabs: true,
}).addTo(map);

